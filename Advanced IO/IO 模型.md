## I/O 模型

为了 OS 的安全性等的考虑，进程是无法直接操作 I/O 设备的，其必须通过系统调用请求内核来协助完成 I/O 动作，而内核会为每个 I/O 设备维护一个 buffer。

整个请求过程为：用户进程发起请求，内核接受到请求后，从 I/O 设备中获取数据到 buffer 中，再将 buffer 中的数据 copy 到用户进程的地址空间，该用户进程获取到数据后再响应客户端。

> **为什么出现多种 I/O 模型？**

在整个请求过程中，数据输入至 buffer 需要时间(第一个阶段)，而从 buffer 复制数据至进程也需要时间(第二个阶段)。因此根据在这两段时间内等待方式的不同，分为不同的 I/O 模型。

I/O 执行两阶段

* 准备数据阶段
* 数据拷贝阶段

> **同步和异步，阻塞和非阻塞**

同步和异步：用户进程与内核的交互方式。

* 同步是指用户进程发起 I/O 请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行
* 异步是指用户进程发起 I/O 请求后仍继续执行，当内核 I/O 操作完成后会通知用户进程，或者调用用户进程注册的回调函数

阻塞和非阻塞：用户进程调用内核 I/O 操作的方式。

* 阻塞是指 I/O 操作需要彻底完成后才返回到用户空间
* 非阻塞是指 I/O 操作被调用后立即返回给用户一个状态值，无需等到 I/O 操作彻底完成

### 阻塞 I/O - (同步阻塞)

传统的 I/O 模型

当用户进程进行系统调用时，内核就开始了 I/O 的第一个阶段，准备数据到缓冲区中，当数据都准备完成后，则将数据从内核缓冲区中拷贝到用户进程的内存中，这时用户进程才解除 block 的状态重新运行。

在阻塞 I/O 模型下，用户进程一直处于阻塞，不能做任何事，只能等到内核处理完后，才解除，这样导致对 CPU 资源利用率不高。

### 非阻塞 I/O - (同步非阻塞)

默认创建的 socket 都是阻塞的，非阻塞 I/O 要求 socket 被设置为 NONBLOCK。

当用户进程发起一个 I/O 请求，就立即返回，并没有读取任何数据，第一阶段是非阻塞。

但是用户进程需要不停地轮询，直到数据到达后，此时用户进程阻塞，进行数据拷贝(第二阶段是非阻塞)，这种是非常耗 CPU 资源。

### I/O 多路复用 - (异步阻塞)

I/O 执行的两个阶段都是用户进程都是阻塞的，但是两个阶段是独立的，在一次完整的 I/O 操作中，该用户进程是发起了两次系统调用。

I/O 多路复用模型是建立在内核提供的多路分离函数 select 基础之上的，使用 select 函数可以避免同步非阻塞 I/O 模型中轮询等待的问题。

用户首先将需要进行 I/O 操作的 socket 添加到 select 中，然后阻塞等待 select 系统调用返回。当数据到达时，socket 被激活，select 函数返回。用户进程正式发起 read 请求，读取数据并继续执行。

从流程上来看，使用 select 函数进行 I/O 请求和同步阻塞模型没有太大的区别，甚至还多了添加监视 socket，以及调用 select 函数的额外操作，效率更差。但是，使用 select 以后最大的优势是用户可以在一个线程内同时处理多个 socket 的 I/O 请求。用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，即可达到在同一个线程内同时处理多个 I/O 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

### 异步 I/O - (异步非阻塞)

当用户进程发起系统调用后，立刻就可以开始去做其它的事情，然后直到 I/O 执行的两个阶段都完成之后，内核会给用户进程发送通知，告诉用户进程操作已经完成了。

所以真正的异步 I/O 是用户进程发起一个请求，然后做其它事情，内核处理完后，会主动发通知给用户进程。

## 参考

* [高性能 IO 模型浅析](http://www.cnblogs.com/fanzhidongyzby/p/4098546.html)
* [浅谈 Linux 下的五种 I/O 模型](http://www.cnblogs.com/chy2055/p/5220793.html)
* [五种 IO 模型](http://www.cnblogs.com/5iedu/p/6341332.html)
* [服务器基础:聊聊 c10k 问题及解决方法](http://blog.csdn.net/sinat_34990639/article/details/52779154)
