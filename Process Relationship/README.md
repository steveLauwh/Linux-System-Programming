## 进程关系

### 孤儿进程

孤儿进程(orphen process)：父进程先结束，子进程就成为孤儿进程，会由1号进程（init 进程）回收。

### 僵尸进程

僵尸进程：子进程先结束，父进程还存在，这时候子进程并没有被完全释放内存(在内核中的 task_struct 没被释放)，该子进程称为僵尸进程(zombie process)。

当僵尸进程(zombie process)的父进程结束后，就会被 init 进程回收。

**避免僵尸进程的方法：**

* 让僵尸进程的父进程来回收，父进程每隔一段时间来查询子进程是否结束并回收。调用 wait 或 waitpid，通知内核释放僵尸进程
* 采用信号 SIGCHLD 通知处理，并在信号处理程序中调用 wait 函数来通知释放僵尸进程
* 让僵尸进程变成孤儿进程，由 init 进程来回收

### 进程链

进程链：父进程创建一个子进程，创建的子进程再次创建出属于自己的子进程，这样依次往下循环。

实现：如果是父进程则退出，保证父进程只会创建一个子进程。如果是子进程继续创建接下来的进程再退出。

### 进程扇

进程扇：一个父进程创建出多个子进程。

实现：判断出子进程则退出，把创建进程的机会只留给父进程。

### 进程组

* 一个或多个进程的集合
* 可以接受同一终端的各种信号，同一个信号发送进程组就等于发送给组中的所有进程
* 每个进程组有唯一的进程组 ID
* 进程组的消亡要等到组中所有的进程结束
* kill 发送信号给进程组：kill -9 -进程组号

### 组长进程

* 每个进程组可以有个组长进程，组长进程的 ID 就是进程组的 ID
* 组长进程可以创建进程组及该组中的进程
* 进程组的创建从第一个进程（组长进程）加入开始
* 进程组的组号取第一个加入组的进程（组长进程）的编号

```c
#include <unistd.h>

// 将进程加入到指定的进程组中，其中 pid 为进程号，pgid 为进程组号。成功返回 0，出错返回 -1
int setpgid(pid_t pid, pid_t pgid);

// 获得进程 pid 所在进程组的 ID，出错返回-1
pid_t getpgid(pid_t pid);

// 返回调用进程的进程组 ID
pid_t getpgrp(void);                 /* POSIX.1 version */
pid_t getpgrp(pid_t pid);            /* BSD version */

// 设置调用进程的进程组 ID
int setpgrp(void);                   /* System V version */
int setpgrp(pid_t pid, pid_t pgid);  /* BSD version */
```

### 前台进程组

* 自动接受终端信号的组称为前台进程组
* 在终端通过 `ctrl+c` 等动作产生的信号首先被前台进程组接受
* 在 shell 启动的若干个进程组默认是父进程所在的组为前台进程组，其他进程组则为后台进程组
* 除非是默认，否则都要通过调度才能成为前台进程组

```c
#include <unistd.h>

// 获取前台进程组 ID，出错返回 -1
pid_t tcgetpgrp(int fd);

// 设置前台进程组 ID，成功返回 0，出错返回 -1
int tcsetpgrp(int fd, pid_t pgrp);
```
